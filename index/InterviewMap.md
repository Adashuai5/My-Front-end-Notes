# 网络

## UDP

（User Datagram Protocol）用户数据报协议

### 过程

- 在 **发送端**，**应用层** 将数据传递给 **传输层** 的 UDP 协议，UDP 只会给数据增加一个 **UDP 头** 标识下是 UDP 协议，然后就传递给 **网络层** 了
- 在 **接收端**，**网络层** 将数据传递给 **传输层**，UDP 只**去除 IP 报文头**就传递给 **应用层**，不会任何拼接操作

### 特点

1. UDP 是 **无连接的**，也就是说通信不需要建立和断开连接。
2. UDP 也是 **不可靠的**，协议收到什么数据就传递什么数据，并且也不会备份数据，不关心的对方能否收到。
3. UDP 没有拥塞控制，一直 **会以恒定的速度发送数据**。即使网络条件不好，也不会对发送速率进行调整。这样实现的 **弊端** 就是在 网络条件不好的情况下可能会导致丢包，但是 **优点** 也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很**高效的**

### 传输方式

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

### 头部

![UDP 头部](https://upload-images.jianshu.io/upload_images/7094266-f824405223679ee7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## TCP

（Transmission Control Protocol）传输控制协议

### 头部

![TCP 头部](https://upload-images.jianshu.io/upload_images/7094266-957efab8a7d36b78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 状态机

![](https://upload-images.jianshu.io/upload_images/7094266-afce51976c9243fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

HTTP 是**无连接的**，所以作为下层的 TCP 协议也是无连接的，看似 TCP 将两端连接了起来，其实只是**两端共同维护了一个状态**。
TCP 的状态机是很复杂的，并且**与建立断开和连接时的握手**息息相关。
一个重要的性能指标 **RTT**：该指标表示 **发送端发送数据到接收到对端数据所需的往返时间**

#### 三次握手

![](https://upload-images.jianshu.io/upload_images/7094266-4b59629d3c700edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
SYN：synchronous 建立联机
ACK：acknowledgement 确认

通讯双方建立一次tcp连接，需要经过三次步骤
1、客户端发送syn包（syn=j）到服务器，并入SYN_SEND状态，等待服务器确认。
2、服务器收入syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），既SYN+ACK包，此时服务器进入SYN_RECV状态。
3、客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
（tcp在握手过程中并不携带数据，而是在三次握手完成之后才会进行数据传送）
```

在 TCP 协议中，主动 **发起请求** 的一端为**客户端**，**被动连接** 的一端称为**服务端**。不管是客户端还是服务端，TCP 连接建立完后**都能发送和接收数据**，所以 TCP 也是一个**全双工的协议**。

起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据。

##### 第一次握手

客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，**客户端**便进入 **SYN-SENT** 状态，x 表示客户端的**数据通信初始序号**。

##### 第二次握手

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会**包含自身的数据通讯初始序号**，发送完成后便进入 **SYN-RECEIVED** 状态。

##### 第三次握手

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。**客户端**发完这个报文段后便进入**ESTABLISHED（确定） 状态**，**服务端**收到这个应答后也进入 **ESTABLISHED 状态**，此时连接建立成功。

PS：第三次握手可以包含数据，通过 **TCP 快速打开（TFO）技术**。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端**存储相同 cookie**，下次握手时发出 cookie 达到**减少 RTT** 的目的。

- **明明两次握手就可以建立起连接，为什么还需要第三次应答？**
  这是**为了防止失效的连接请求报文段被服务端接收**，从而产生错误。

PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。

#### [#](https://yuchengkai.cn/docs/cs/#%E6%96%AD%E5%BC%80%E9%93%BE%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B)断开链接四次握手

---

### JSONP

JSONP 的原理很简单，就是利用 <script> 标签没有跨域限制的漏洞。通过 <script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。

### CORS

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS
